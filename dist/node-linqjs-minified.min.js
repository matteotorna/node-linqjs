(e=>{class f{constructor(e){this.source=e}[Symbol.iterator](){return this.source[Symbol.iterator]()}static from(e){return new f(e)}where(r){let t=this;return new f({*[Symbol.iterator](){for(var e of t)r(e)&&(yield e)}})}select(r){let t=this;return new f({*[Symbol.iterator](){for(var e of t)yield r(e)}})}selectMany(r){let t=this;return new f({*[Symbol.iterator](){for(var e of t)yield*r(e)}})}orderBy(e){return new r(this,e,!1)}orderByDescending(e){return new r(this,e,!0)}take(t){let n=this;return new f({*[Symbol.iterator](){let e=0;for(var r of n){if(e>=t)break;yield r,e++}}})}takeWhile(r){let t=this;return new f({*[Symbol.iterator](){for(var e of t){if(!r(e))break;yield e}}})}skip(t){let n=this;return new f({*[Symbol.iterator](){let e=0;for(var r of n)e>=t?yield r:e++}})}skipWhile(t){let n=this;return new f({*[Symbol.iterator](){let e=!0;for(var r of n)(e=e&&!t(r)?!1:e)||(yield r)}})}first(e=null){for(var r of this)if(null===e||e(r))return r;throw new Error("Sequence contains no matching elements")}firstOrDefault(e=null,r=null){try{return this.first(e)}catch{return r}}last(e=null){let r=void 0,t=!1;for(var n of this)null!==e&&!e(n)||(r=n,t=!0);if(t)return r;throw new Error("Sequence contains no matching elements")}lastOrDefault(e=null,r=null){try{return this.last(e)}catch{return r}}single(e=null){let r=!1,t=void 0;for(var n of this)if(null===e||e(n)){if(r)throw new Error("Sequence contains more than one matching element");t=n,r=!0}if(r)return t;throw new Error("Sequence contains no matching elements")}singleOrDefault(e=null,r=null){try{return this.single(e)}catch(e){if("Sequence contains no matching elements"===e.message)return r;throw e}}elementAt(e){let r=0;for(var t of this){if(r===e)return t;r++}throw new Error("Index out of range")}elementAtOrDefault(e,r=null){try{return this.elementAt(e)}catch{return r}}sum(e=e=>e){let r=0;for(var t of this)r+=e(t);return r}average(e=e=>e){let r=0,t=0;for(var n of this)r+=e(n),t++;if(0===t)throw new Error("Sequence contains no elements");return r/t}min(e=e=>e){let r=void 0;for(var t of this){t=e(t);(void 0===r||t<r)&&(r=t)}if(void 0===r)throw new Error("Sequence contains no elements");return r}max(e=e=>e){let r=void 0;for(var t of this){t=e(t);(void 0===r||t>r)&&(r=t)}if(void 0===r)throw new Error("Sequence contains no elements");return r}groupBy(e,r=e=>e){var t,n=new Map;for(t of this){var o=e(t),i=r(t);n.has(o)||n.set(o,[]),n.get(o).push(i)}return new f(n)}distinct(t=(e,r)=>e===r){let n=this;return new f({*[Symbol.iterator](){var e=new Set;for(let r of n)Array.from(e).some(e=>t(e,r))||(e.add(r),yield r)}})}union(t,n=(e,r)=>e===r){let o=this;return new f({*[Symbol.iterator](){var e=new Set;for(let r of o)Array.from(e).some(e=>n(e,r))||(e.add(r),yield r);for(let r of t)Array.from(e).some(e=>n(e,r))||(e.add(r),yield r)}})}intersect(r,n=(e,r)=>e===r){let o=this;return new f({*[Symbol.iterator](){var e=Array.from(r),t=new Set;for(let r of o)e.some(e=>n(e,r))&&!Array.from(t).some(e=>n(e,r))&&(t.add(r),yield r)}})}except(r,n=(e,r)=>e===r){let o=this;return new f({*[Symbol.iterator](){var e=Array.from(r),t=new Set;for(let r of o)e.some(e=>n(e,r))||Array.from(t).some(e=>n(e,r))||(t.add(r),yield r)}})}concat(e){let r=this;return new f({*[Symbol.iterator](){yield*r,yield*e}})}reverse(){return new f([...this].reverse())}sequenceEqual(e,r=(e,r)=>e===r){var t,n=e[Symbol.iterator]();for(t of this){var{value:o,done:i}=n.next();if(i||!r(t,o))return!1}return n.next().done}zip(o,i){let l=this;return new f({*[Symbol.iterator](){for(var e=l[Symbol.iterator](),r=o[Symbol.iterator]();;){var t=e.next(),n=r.next();if(t.done||n.done)break;yield i(t.value,n.value)}}})}join(o,i,l,a){let s=this;return new f({*[Symbol.iterator](){var e,r=Array.from(o);for(e of s){var t,n=i(e);for(t of r)n===l(t)&&(yield a(e,t))}}})}groupJoin(r,o,i,l){let a=this;return new f({*[Symbol.iterator](){var e,t=Array.from(r);for(e of a){let r=o(e);var n=t.filter(e=>r===i(e));yield l(e,new f(n))}}})}defaultIfEmpty(t=null){let n=this;return new f({*[Symbol.iterator](){let e=!1;for(var r of n)e=!0,yield r;e||(yield t)}})}all(e){for(var r of this)if(!e(r))return!1;return!0}any(e=null){for(var r of this)if(null===e||e(r))return!0;return!1}contains(e,r=(e,r)=>e===r){for(var t of this)if(r(t,e))return!0;return!1}count(e=null){let r=0;for(var t of this)null!==e&&!e(t)||r++;return r}aggregate(e,r,t=e=>e){let n=e;for(var o of this)n=r(n,o);return t(n)}toArray(){return[...this]}toSet(){return new Set(this)}toMap(e=(e,r)=>r,r=e=>e){var t,n=new Map;let o=0;for(t of this)n.set(e(t,o),r(t,o)),o++;return n}toDictionary(e,r=e=>e){var t,n={};for(t of this){var o=e(t);if(o in n)throw new Error("Duplicate key");n[o]=r(t)}return n}toLookup(e,r=e=>e){var t,n={};for(t of this){var o=e(t);o in n||(n[o]=[]),n[o].push(r(t))}return n}cast(t){let e=this;return new f({*[Symbol.iterator](){for(let r of e)if(t===Number)yield Number(r);else if(t===String)yield String(r);else if(t===Boolean)yield Boolean(r);else if(t===BigInt)yield BigInt(r);else if(t===Symbol)yield Symbol(r.toString());else if(t===Object)yield Object(r);else if(t===Array)yield Array.isArray(r)?r:[r];else if(t===Function)yield"function"==typeof r?r:()=>r;else if(t===Date)yield r instanceof Date?r:new Date(r);else if(t===RegExp)yield r instanceof RegExp?r:new RegExp(r);else if(t===Error)yield r instanceof Error?r:new Error(r);else if("function"==typeof t)try{yield new t(r)}catch(e){yield t(r)}else yield r}})}ofType(r){return this.where(e=>typeof e===r)}chunk(t){if(t<=0)throw new Error("Size must be greater than 0");let n=this;return new f({*[Symbol.iterator](){let e=[];for(var r of n)e.push(r),e.length===t&&(yield e,e=[]);0<e.length&&(yield e)}})}prepend(e){let r=this;return new f({*[Symbol.iterator](){yield e,yield*r}})}append(e){let r=this;return new f({*[Symbol.iterator](){yield*r,yield e}})}forEach(e){for(var r of this)e(r)}aggregate(e){var r,t=this[Symbol.iterator]().next();if(t.done)throw new Error("Sequence contains no elements");let n=t.value;for(r of this)n=e(n,r);return n}sequenceEqual(e,r=(e,r)=>e===r){var t,n=e[Symbol.iterator]();for(t of this){var{value:o,done:i}=n.next();if(i||!r(t,o))return!1}return n.next().done}static empty(){return new f([])}static range(r,t){if(t<0)throw new Error("Count must be non-negative");return new f({*[Symbol.iterator](){for(let e=0;e<t;e++)yield r+e}})}static repeat(r,t){if(t<0)throw new Error("Count must be non-negative");return new f({*[Symbol.iterator](){for(let e=0;e<t;e++)yield r}})}distinctBy(n){let o=this;return new f({*[Symbol.iterator](){var e,r=new Set;for(e of o){var t=n(e);r.has(t)||(r.add(t),yield e)}}})}skipLast(t){if(t<0)throw new Error("Count must be non-negative");let n=this;return new f({*[Symbol.iterator](){var e,r=[];for(e of n)r.push(e),t<r.length&&(yield r.shift())}})}takeLast(t){if(t<0)throw new Error("Count must be non-negative");let n=this;return new f({*[Symbol.iterator](){var e,r=[];for(e of n)r.push(e),t<r.length&&r.shift();yield*r}})}}class r extends f{constructor(e,r,t=!1){super(e),this.keySelectors=[{keySelector:r,descending:t}]}thenBy(e){return this.keySelectors.push({keySelector:e,descending:!1}),this}thenByDescending(e){return this.keySelectors.push({keySelector:e,descending:!0}),this}[Symbol.iterator](){var e=[...this.source];return e.sort((e,r)=>{for(var{keySelector:t,descending:n}of this.keySelectors){var o=t(e),t=t(r);if(o<t)return n?1:-1;if(t<o)return n?-1:1}return 0}),e[Symbol.iterator]()}}e.linq=function(e){return new f(e)}})("undefind"!=typeof window?window:this);